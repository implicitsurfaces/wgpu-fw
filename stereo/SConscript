import itertools
import os.path
import re
import shutil

Import('env')

# todo: clone the env

arch = env['ARCH']

SERVE_OUT = '#/html'

EXPORTED_FNS = [
    '_initGL',
    '_size_window',
    '_draw_scene',
    # '_refresh_shaders',
    # '_paste_text'
]

EXPORTED_RUNTIME_FNS = [
    'cwrap',
    'setValue',
]

BUNDLED_FILES = []

data_out = '#/resource'

PROJECT_RESOURCE_EXTS = [
    '.glsl',
    '.wgsl',
]

extra_wasm_linkflags = {
    'EXPORTED_FUNCTIONS'       : ','.join(EXPORTED_FNS),
    'EXPORTED_RUNTIME_METHODS' : ','.join(EXPORTED_RUNTIME_FNS),
}

# here's how the web deploy works:
#   wrapper.ts builds to wrapper.js
#   {module}.js is an auto-generated JS module which loads the compiled WASM
#   {module}.wasm is generated by emscripten together with {module}.js
#   {module}.html includes wrapper.js, {module}.js, and main.css.
#     it passes the canvas object to the wrapper code and sets a callback for when
#     the WASM is loaded
#   wrapper.{ts,js} initializes wrapped C ffi functions, calls resize functions,
#     passes events and other info from the browser, calls requestAnimationFrame().


# no builtin recursive search :(
obj_sources    = [Glob('*/*.cpp'), Glob('*/*/*.cpp'), Glob('*/*/*/*.cpp')]
prog_sources   = Glob('*.cpp')
shader_sources = Glob('shaders/*.wgsl')
shader_out_dir = os.path.join(data_out, 'shaders')

indexes = []

programs = []
default_targets = []


# WGSL include expansion

INCLUDE_PATTERN = re.compile(r'^#include\s+"([^"]+)"')

def extract_immediate_includes(fname):
    incs = []
    with open(fname, 'r') as f:
        for line in f:
            line = line.strip()
            is_comment = False
            if line.startswith('//'):
                line = line[2:].strip()
                is_comment = True
            match = INCLUDE_PATTERN.match(line)
            if match:
                incname = match.group(1)
                incpath = os.path.join(os.path.dirname(fname), incname)
                incs.append(incpath)
            # continue until we hit code
            # (not an include, comment, or empty line)
            if not (match or is_comment or line == ''):
                break
    return incs

def evaluate_deps(target, source, env, seen=None):
    if seen is None:
        seen = set()
    srcpath = str(source)
    incs    = set(extract_immediate_includes(srcpath))
    for i in incs:
        if i not in seen:
            seen.add(i)
            inc_source = env.File(i)
            env.Depends(target, inc_source)
            evaluate_deps(target, inc_source, env, seen)

def expand_includes(target, source, env, seen=None):
    if seen is None:
        seen = set()
    srcpath = str(source)
    dstpath = str(target)
    incs    = extract_immediate_includes(srcpath)
    for i in incs:
        if i in seen:
            continue
        seen.add(i)
        inc_source = env.File(i)
        # fully expand the include, recursively copying the contents of the
        # included files into the destination file, with the include
        # itself coming last
        expand_includes(target, inc_source, env, seen)
    
    with open(dstpath, 'a') as dst_f:
        # copy the contents of the source file to the destination
        with open(srcpath, 'r') as src_f:
            dst_f.write(f"// expanded from `{srcpath}` {{\n")
            shutil.copyfileobj(src_f, dst_f)
            dst_f.write(f"// }} end `{srcpath}` expansion\n")

def WgslExpand(env, target, source):
    for t in target:
        for s in source:
            expand_includes(t, s, env)

wgsl_builder = Builder(action=WgslExpand)
env.Append(BUILDERS={'WgslExpand' : wgsl_builder})

for f in shader_sources:
    built_shader = env.File(os.path.join(shader_out_dir, f.name))
    evaluate_deps(built_shader, f, env)
    s = env.WgslExpand(target=built_shader, source=f)
    default_targets.append(s)

# ordinary build

if arch == 'wasm':
    preload_flags = itertools.chain(*
        (('--preload-file', env.File(f).abspath) for f in BUNDLED_FILES)
    )
    env.Append(LINKFLAGS=env.subst_wasm_flags(extra_wasm_linkflags))
    env.Append(LINKFLAGS=list(preload_flags))
    module = 'main'
    prog_target = f'{SERVE_OUT}/{module}.js'
    # point a copy of the index at this module.
    # (we have to escape the $ in the substitution string, otherwise
    # scons will treat it as in internal variable and try to replace it)
    index = env.Substfile('#/web/index.html', SUBST_DICT={'%MODULE_NAME%' : module})
    indexes.append(env.InstallAs(f'{SERVE_OUT}/{module}.html', index))
        
    # web boilerplate
    # build ts file to js:
    wrapper = env.Ts(source='#/web/wrapper.ts', target=f'{SERVE_OUT}/wrapper.js')
    # copy main css to serve directory:
    css = env.Install(SERVE_OUT, '#/web/main.css')

    serve_path = env.GetBuildPath(SERVE_OUT)
    serve = env.Command(
        'serve',
        [prog_target, wrapper, css, indexes], 
        f'python3 -m http.server 8000 -d {serve_path}')
    env.Alias('serve', serve)
    default_targets.append(serve)
else:
    for p in prog_sources:
        # remove the path and extension to get the program name
        prog_name     = os.path.splitext(os.path.basename(str(p)))[0]
        prog_target   = f'#/bin/{prog_name}'
        prog = env.Program(prog_target, source=[p, *obj_sources])
        programs.append(prog)

# install shader files
# shader_out_dir = os.path.join(data_out, 'shaders')
# default_targets.append(
#     env.Install(env.Dir(shader_out_dir), shader_sources)
# )

Default([*programs, *default_targets])

Return('main')
