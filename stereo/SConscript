import itertools
import os.path
import re
import shutil
import sys

Import('env')

# todo: clone the env

arch = env['ARCH']

SERVE_OUT = '#/html'

EXPORTED_FNS = [
    '_initGL',
    '_size_window',
    '_draw_scene',
    # '_refresh_shaders',
    # '_paste_text'
]

EXPORTED_RUNTIME_FNS = [
    'cwrap',
    'setValue',
]

BUNDLED_FILES = []

data_out = '#/resource'

PROJECT_RESOURCE_EXTS = [
    '.glsl',
    '.wgsl',
]

extra_wasm_linkflags = {
    'EXPORTED_FUNCTIONS'       : ','.join(EXPORTED_FNS),
    'EXPORTED_RUNTIME_METHODS' : ','.join(EXPORTED_RUNTIME_FNS),
}

# here's how the web deploy works:
#   wrapper.ts builds to wrapper.js
#   {module}.js is an auto-generated JS module which loads the compiled WASM
#   {module}.wasm is generated by emscripten together with {module}.js
#   {module}.html includes wrapper.js, {module}.js, and main.css.
#     it passes the canvas object to the wrapper code and sets a callback for when
#     the WASM is loaded
#   wrapper.{ts,js} initializes wrapped C ffi functions, calls resize functions,
#     passes events and other info from the browser, calls requestAnimationFrame().


# no builtin recursive search :(
obj_sources    = [Glob(f'{x}/*.cpp', exclude=[f'{x}/main.cpp']) for x in ['*', '*/*', '*/*/*']]
prog_sources   = [*Glob('*.cpp'), *Glob('*/main.cpp')]
shader_sources = Glob('shaders/**/*.wgsl')
shader_out_dir = data_out # `shaders/` gets appended from the src path

indexes = []

programs = []
default_targets = []


# WGSL include expansion

INCLUDE_PATTERN = re.compile(r'^#include\s+"([^"]+)"')

def extract_immediate_includes(fname):
    incs = []
    try:
        with open(fname, 'r') as f:
            for line in f:
                line = line.strip()
                is_comment = False
                if line.startswith('//'):
                    line = line[2:].strip()
                    is_comment = True
                match = INCLUDE_PATTERN.match(line)
                if match:
                    incname = match.group(1)
                    incpath = os.path.join(os.path.dirname(fname), incname)
                    incs.append(incpath)
                # continue until we hit code
                # (not an include, comment, or empty line)
                # >> EDIT: removed, because we have some cases where we need
                #   mid-file includes due to laguage limitations (storage arrays
                #   as fn parameters). read the whole gottdang file instead
                # if not (match or is_comment or line == ''):
                #     break
    except FileNotFoundError:
        wdir = os.getcwd()
        print(f"warning: file `{fname}` not found from {wdir}", file=sys.stderr)
        pass
    return incs

# issue: path construction not correct on expansion

def evaluate_deps(target, source, env, seen=None):
    if seen is None:
        seen = set()
    srcpath = source.srcnode().abspath
    incs    = set(extract_immediate_includes(srcpath))
    for i in incs:
        if i not in seen:
            seen.add(i)
            inc_source = env.File(i)
            env.Depends(target, inc_source)
            evaluate_deps(target, inc_source, env, seen)

def expand_includes(target, source, env, seen=None):
    if seen is None:
        seen = set()
    srcpath = source.srcnode().abspath
    dstpath = str(target)
    incs    = extract_immediate_includes(srcpath)
    for i in incs:
        if i in seen:
            continue
        seen.add(i)
        inc_source = env.File(i)
        # fully expand the include, recursively copying the contents of the
        # included files into the destination file, with the include
        # itself coming last
        expand_includes(target, inc_source, env, seen)

    with open(dstpath, 'a') as dst_f:
        # copy the contents of the source file to the destination
        with open(srcpath, 'r') as src_f:
            dst_f.write(f"// expanded from `{srcpath}` {{\n")
            shutil.copyfileobj(src_f, dst_f)
            dst_f.write(f"// }} end `{srcpath}` expansion\n")

def WgslExpand(env, target, source):
    for t in target:
        # dstpath = str(t)
        # dirpath = os.path.dirname(dstpath)
        # if not os.path.exists(dirpath):
        #     os.makedirs(dirpath)
        for s in source:
            expand_includes(t, s, env)

wgsl_builder = Builder(action=WgslExpand)
env.Append(BUILDERS={'WgslExpand' : wgsl_builder})

for f in shader_sources:
    built_shader = env.File(os.path.join(shader_out_dir, str(f)))
    print(f"defining built shader {str(built_shader)} from {str(f)}")
    evaluate_deps(built_shader, f, env)
    s = env.WgslExpand(target=built_shader, source=f)
    default_targets.append(s)

# ordinary build

t = None

if arch == 'wasm':
    preload_flags = itertools.chain(*
        (('--preload-file', env.File(f).abspath) for f in BUNDLED_FILES)
    )
    env.Append(LINKFLAGS=env.subst_wasm_flags(extra_wasm_linkflags))
    env.Append(LINKFLAGS=list(preload_flags))
    module = 'main'
    prog_target = f'{SERVE_OUT}/{module}.js'
    # point a copy of the index at this module.
    # (we have to escape the $ in the substitution string, otherwise
    # scons will treat it as in internal variable and try to replace it)
    index = env.Substfile('#/web/index.html', SUBST_DICT={'%MODULE_NAME%' : module})
    indexes.append(env.InstallAs(f'{SERVE_OUT}/{module}.html', index))

    # web boilerplate
    # build ts file to js:
    wrapper = env.Ts(source='#/web/wrapper.ts', target=f'{SERVE_OUT}/wrapper.js')
    # copy main css to serve directory:
    css = env.Install(SERVE_OUT, '#/web/main.css')

    serve_path = env.GetBuildPath(SERVE_OUT)
    serve = env.Command(
        'serve',
        [prog_target, wrapper, css, indexes],
        f'python3 -m http.server 8000 -d {serve_path}')
    env.Alias('serve', serve)
    default_targets.append(serve)
else:
    for p in prog_sources:
        # remove the path and extension to get the program name
        prog_file     = str(p)
        prog_dir      = os.path.dirname(prog_file)
        prog_name     = os.path.splitext(os.path.basename(prog_file))[0]
        if prog_name == 'main' and prog_dir:
            prog_name = prog_dir
        prog_target   = f'#/bin/{prog_name}'
        prog = env.Program(prog_target, source=[p, *obj_sources])
        programs.append(prog)
        if prog_name == 'sdf':
            t = prog # uhhhhhhhh

# install shader files
# shader_out_dir = os.path.join(data_out, 'shaders')
# default_targets.append(
#     env.Install(env.Dir(shader_out_dir), shader_sources)
# )

Default([*programs, *default_targets])

Return('t')
